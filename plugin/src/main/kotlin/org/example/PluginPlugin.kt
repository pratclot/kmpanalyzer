/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import org.gradle.api.Named
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.tasks.SourceSetContainer
import org.gradle.tooling.provider.model.ToolingModelBuilder
import org.gradle.tooling.provider.model.ToolingModelBuilderRegistry
import javax.inject.Inject
import kotlin.reflect.full.memberProperties
import kotlin.reflect.jvm.isAccessible

const val KMP_PLUGIN_ID = "org.jetbrains.kotlin.multiplatform"

/**
 * A simple 'hello world' plugin.
 */
class PluginPlugin @Inject constructor(
    @Inject
    private val registry: ToolingModelBuilderRegistry
) : Plugin<Project> {

    override fun apply(project: Project) {
        registry.register(CustomToolingModelBuilder())

//        "Guarded" by a RUN_TOOLING_TEST property
        project.properties["RUN_TOOLING_TEST"]?.let {
            project.allprojects { subproject ->
                subproject.pluginManager.withPlugin(KMP_PLUGIN_ID) {
                    println("processing $subproject")
                    registry.getBuilder(CustomModel::class.java.name).buildAll(CustomModel::class.java.name, subproject)
                }
            }
        }

        // Register a task
        project.tasks.register("greeting") { task ->
            task.doLast {
                println("Hello from plugin 'org.example.greeting'")
            }
        }
    }
}


class CustomToolingModelBuilder : ToolingModelBuilder {
    override fun canBuild(modelName: String): Boolean {
        return modelName == CustomModel::class.java.name
    }

    override fun buildAll(modelName: String, project: Project): Any {
//        println("running CustomToolingModelBuilder.buildAll() for $modelName and ${project.name}")
        val pluginClassNames: MutableList<String> = ArrayList()

        for (plugin in project.plugins) {
            pluginClassNames.add(plugin.javaClass.name)
        }

        val projectsWithSourceSets = project.allprojects
            .map(::getSourceSets)

        return DefaultModel(
            plugins = pluginClassNames,
            sourceSets = emptyList(),
            projectsWithSourceSets = projectsWithSourceSets,
            projectName = project.name,
        )
    }

    //    Modified copypasta from JetBrains' `pill` project
    private fun getSourceSets(project: Project): Map<String, List<String>> {
        return buildMap {

            val kotlinExtension = project.extensions.findByName("kotlin")
            if (kotlinExtension != null) {

                val hierarchy = kotlinExtension::class.memberProperties
                    .single { it.name == "hierarchy" }
                    .call(kotlinExtension)

                hierarchy?.let {
                    val methodForSourceSets = it::class.memberProperties.single { it.name == "sourceSets" }
                    methodForSourceSets.isAccessible = true
                    (methodForSourceSets.call(hierarchy) as Iterable<*>)
                        .filterNotNull()
                        .map {
                            val methodForDependsOn = it::class.memberProperties.single { it.name == "dependsOn" }
                            it as Named
                            val methodResult = methodForDependsOn.call(it) as? Iterable<*>
//                            The Tooling API will attempt to serialize source sets, so we convert them to strings here.
                            val dependenciesMappedToStrings = methodResult
                                ?.filterNotNull()
                                ?.map {
                                    val projectProperty = it::class.memberProperties.single { it.name == "project" }
                                    "${projectProperty.call(it)}: ${(it as Named).name}"
                                }
                            "$project: ${it.name}" to (dependenciesMappedToStrings ?: emptyList()).toList()
                        }
                        .let(::putAll)
                }
            }
        }
    }
}

private val Project.sourceSets: SourceSetContainer?
    get() {
        val javaExtension =
            project.extensions.findByType<JavaPluginExtension>(JavaPluginExtension::class.java) ?: return null
        return javaExtension.sourceSets
    }